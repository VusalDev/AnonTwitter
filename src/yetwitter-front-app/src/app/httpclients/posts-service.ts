//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class PostClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost/api";
    }

    /**
     * Создать запись
     * @return Успешная операция
     */
    create(body: CreatePostModel): Promise<CreatePostResponseModel> {
        let url_ = this.baseUrl + "/v1/post";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CreatePostResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatePostResponseModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatePostResponseModel>(null as any);
    }

    /**
     * Удалить запись
     * @param postId Идентификатор записи
     * @return Успешная операция
     */
    delete(postId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/post";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Искать записи
     * @param query Поисковая строка
     * @param pageLimit (optional) Максимальное число записей в ответе
     * @param pageSkip (optional) Смещение числа записей
     * @return Успешная операция
     */
    queryPosts(query: string, pageLimit: number | undefined, pageSkip: number | undefined): Promise<QueryPostResponseModel> {
        let url_ = this.baseUrl + "/v1/post?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        if (pageLimit === null)
            throw new Error("The parameter 'pageLimit' cannot be null.");
        else if (pageLimit !== undefined)
            url_ += "pageLimit=" + encodeURIComponent("" + pageLimit) + "&";
        if (pageSkip === null)
            throw new Error("The parameter 'pageSkip' cannot be null.");
        else if (pageSkip !== undefined)
            url_ += "pageSkip=" + encodeURIComponent("" + pageSkip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryPosts(_response);
        });
    }

    protected processQueryPosts(response: Response): Promise<QueryPostResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryPostResponseModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QueryPostResponseModel>(null as any);
    }

    /**
     * Получить записи пользователя
     * @param userId Идентификатор пользователя
     * @param pageLimit (optional) Максимальное число записей в ответе
     * @param pageSkip (optional) Смещение числа записей
     * @return Успешная операция
     */
    getPostsByUser(userId: string, pageLimit: number | undefined, pageSkip: number | undefined): Promise<QueryPostResponseModel> {
        let url_ = this.baseUrl + "/v1/post/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (pageLimit === null)
            throw new Error("The parameter 'pageLimit' cannot be null.");
        else if (pageLimit !== undefined)
            url_ += "pageLimit=" + encodeURIComponent("" + pageLimit) + "&";
        if (pageSkip === null)
            throw new Error("The parameter 'pageSkip' cannot be null.");
        else if (pageSkip !== undefined)
            url_ += "pageSkip=" + encodeURIComponent("" + pageSkip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPostsByUser(_response);
        });
    }

    protected processGetPostsByUser(response: Response): Promise<QueryPostResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryPostResponseModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QueryPostResponseModel>(null as any);
    }

    /**
     * Получить записи по тегу
     * @param pageLimit (optional) Максимальное число записей в ответе
     * @param pageSkip (optional) Смещение числа записей
     * @return Успешная операция
     */
    getPostsByHashTag(hashTag: string, pageLimit: number | undefined, pageSkip: number | undefined): Promise<QueryPostResponseModel> {
        let url_ = this.baseUrl + "/v1/post/{hashTag}?";
        if (hashTag === undefined || hashTag === null)
            throw new Error("The parameter 'hashTag' must be defined.");
        url_ = url_.replace("{hashTag}", encodeURIComponent("" + hashTag));
        if (pageLimit === null)
            throw new Error("The parameter 'pageLimit' cannot be null.");
        else if (pageLimit !== undefined)
            url_ += "pageLimit=" + encodeURIComponent("" + pageLimit) + "&";
        if (pageSkip === null)
            throw new Error("The parameter 'pageSkip' cannot be null.");
        else if (pageSkip !== undefined)
            url_ += "pageSkip=" + encodeURIComponent("" + pageSkip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPostsByHashTag(_response);
        });
    }

    protected processGetPostsByHashTag(response: Response): Promise<QueryPostResponseModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryPostResponseModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QueryPostResponseModel>(null as any);
    }
}

export class RaitingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost/api";
    }

    /**
     * Нравится запись
     * @param postId Идентификатор записи
     * @return Успешная операция
     */
    like(postId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/raiting/like";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLike(_response);
        });
    }

    protected processLike(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Не нравится запись
     * @param postId Идентификатор записи
     * @return Успешная операция
     */
    dislike(postId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/raiting/like";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDislike(_response);
        });
    }

    protected processDislike(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorProblemDetails.fromJS(resultData400);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class PaginationResponse implements IPaginationResponse {
    totalPages?: number;
    currentPage?: number;

    constructor(data?: IPaginationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
        }
    }

    static fromJS(data: any): PaginationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        return data;
    }
}

export interface IPaginationResponse {
    totalPages?: number;
    currentPage?: number;
}

export class QueryPostResponseModel extends PaginationResponse implements IQueryPostResponseModel {
    items?: Post[];

    constructor(data?: IQueryPostResponseModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Post.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QueryPostResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new QueryPostResponseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQueryPostResponseModel extends IPaginationResponse {
    items?: Post[];
}

export class CreatePostModel implements ICreatePostModel {
    rawtext!: string;

    constructor(data?: ICreatePostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawtext = _data["rawtext"];
        }
    }

    static fromJS(data: any): CreatePostModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rawtext"] = this.rawtext;
        return data;
    }
}

export interface ICreatePostModel {
    rawtext: string;
}

export class CreatePostResponseModel implements ICreatePostResponseModel {
    id!: string;

    constructor(data?: ICreatePostResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreatePostResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreatePostResponseModel {
    id: string;
}

export class Post implements IPost {
    text!: string;
    hashtags?: string[];
    appeals?: string[];

    constructor(data?: IPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            if (Array.isArray(_data["hashtags"])) {
                this.hashtags = [] as any;
                for (let item of _data["hashtags"])
                    this.hashtags!.push(item);
            }
            if (Array.isArray(_data["appeals"])) {
                this.appeals = [] as any;
                for (let item of _data["appeals"])
                    this.appeals!.push(item);
            }
        }
    }

    static fromJS(data: any): Post {
        data = typeof data === 'object' ? data : {};
        let result = new Post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        if (Array.isArray(this.hashtags)) {
            data["hashtags"] = [];
            for (let item of this.hashtags)
                data["hashtags"].push(item);
        }
        if (Array.isArray(this.appeals)) {
            data["appeals"] = [];
            for (let item of this.appeals)
                data["appeals"].push(item);
        }
        return data;
    }
}

export interface IPost {
    text: string;
    hashtags?: string[];
    appeals?: string[];
}

export class ProblemDetails implements IProblemDetails {
    type?: string;
    title!: string;
    detail?: string;
    status!: number;
    traceId?: string;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.detail = _data["detail"];
            this.status = _data["status"];
            this.traceId = _data["traceId"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["detail"] = this.detail;
        data["status"] = this.status;
        data["traceId"] = this.traceId;
        return data;
    }
}

export interface IProblemDetails {
    type?: string;
    title: string;
    detail?: string;
    status: number;
    traceId?: string;
}

export class ErrorProblemDetails extends ProblemDetails implements IErrorProblemDetails {
    errors?: any;

    constructor(data?: IErrorProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.errors = _data["errors"];
        }
    }

    static override fromJS(data: any): ErrorProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errors"] = this.errors;
        super.toJSON(data);
        return data;
    }
}

export interface IErrorProblemDetails extends IProblemDetails {
    errors?: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}